# Functions for FlowSOM (and FlowMeans)

getSample <- function(data, n = 1000, seed = 42){
  set.seed(seed)
  ix <- sample(1:length(data[, 1]), size = n)
  data[ix, ]
}

getIDs <- function(inputsample){
  as.integer(dimnames(inputsample)[[1]])
}

meanARI <- function(labels){
  m <- c()
  for(i in 1:length(labels)){
    for(j in 1:length(labels)){
      if(i != j && i < j){
        m <- c(m, ARI(labels[[i]], labels[[j]]))
      }
    }
  }
  m
}

meanClustComp <- function(labels){
  measures <- setNames(data.frame(matrix(ncol = 9, nrow = 0)), c('RI','ARI','MI','AMI','VI','NVI','ID','NID','NMI'))
  for(i in 1:length(labels)){
    for(j in 1:length(labels)){
      if(i != j && i < j){
        measures[nrow(measures)+1, ] <- as.numeric(clustComp(labels[[i]], labels[[j]]))
      }
    }
  }
  measures
}


timeSpent <- function(t){
  # useage: # plot(tapply(results$time_spent, results$sampleSize, timeSpent ))
  t <- sapply(t, strsplit, split=' ')
  tim <- NULL
  for(element in t){
    if(element[2] == 'secs'){
      sec <- as.numeric(element[1])
      tim <- c(tim,sec)
    }else{
      min <- as.numeric(element[1])*60
      tim <- c(tim,min)
    }
    
  }
  print(paste0('The maximal run time is ', max(tim)/60, ' minutes'))
  sum(tim)
}


repFlowSOM <- function(data, marker_cols, nclust = 21, n = 10000, n_stable = 1000, reps = 10, seed = 42){
  # This function runs FlowSOM clustering a number of times, exports the results, and compute the mean adjusted rand index.
  # Input:  data - a data.frame of cytometry data
  #         marker_cols - the coloumns fra data to be used for the clustering (e.g. lineage_channels)
  #         nclust - number of clusters generated by FlowSOM (NA to generate automatically)
  #         n - sample size
  #         n_stable - sample size of the stability determining sample
  #         reps - number of times the clustering will be repeated
  #         seed - for reproducability
  # Output: labels - the clustering results
  #         The mean adjusted rand index will be printed
  # Dependencies: The functions "getSample", "getIDs", and "meanAdjustedRandIndex".
  # Usage:  labels <- repFlowSOM(data, lineage_channels)

  # Construct the small sample for determining the stability:
  data <- data[, lineage_channels]
  # data_1k <- expr[expr$population=="CD4pos", lineage_channels]
  sample_1k <- getSample(data, n = n_stable, seed = seed)
  sample_1k_ids <- getIDs(sample_1k)
  data <- data[-sample_1k_ids, ]
  if(n <= 0){
    n = length(data[[1]])
  }
  labels <- list()
  seed_sample <- seed
  for(run in 0:(reps-1)){
    print(paste("Run", (run+1), "Seed:", seed_sample))
    # Construct the sample (of size n) to use for the clustering
    sample_9k <- getSample(data, n = n-n_stable, seed = seed_sample)
    sample <- rbind(sample_1k, sample_9k)

    # Create FlowFrame from data
    data_FlowSOM <- flowCore::flowFrame(as.matrix(sample))

    # Set seed for reproducibility
    set.seed(seed)

    # Run FlowSOM (initial steps prior to meta-clustering)
    fSOM <- FlowSOM::ReadInput(data_FlowSOM, transform = FALSE, scale = FALSE, silent = TRUE)
    fSOM <- FlowSOM::BuildSOM(fSOM, colsToUse = marker_cols, silent = TRUE)
    fSOM <- FlowSOM::BuildMST(fSOM, silent = TRUE)

    # Extract cluster labels (pre meta-clustering) from output object
    labels_pre <- fSOM$map$mapping[, 1]

    # Run FlowSOM meta-clustering
    fSOM_Cluster <- FlowSOM::metaClustering_consensus(fSOM$map$codes, k = nclust, seed = seed)

    labels <- append(labels, list(fSOM_Cluster[labels_pre][1:length(sample_1k[[1]])]))
    seed_sample <- seed_sample + 1
  }
  #print(paste('The Mean Adjusted Rand Index:', mean(meanAdjustedRandIndex(labels))))
  labels
}


repFlowMeans <- function(data, marker_cols, nclust = 21, n = 10000, reps = 10, n_stable = 1000, seed = 42){
  # This function runs FlowMeans clustering a number of times, exports the results, and compute the mean adjusted rand index.
  # Input:  data - a data.frame of cytometry data
  #         marker_cols - the coloumns fra data to be used for the clustering (e.g. lineage_channels)
  #         nclust - number of clusters generated by FlowMeans
  #         n - sample size (The stable cells will be a 10th of this number)
  #         reps - number of times the clustering will be repeated
  #         n_stable - sample size of the stability determining sample
  #         seed - for reproducability
  # Output: labels - the clustering results
  #         The mean adjusted rand index will be printed
  # Dependencies: The functions "getSample", "getIDs", and "meanAdjustedRandIndex".
  # Usage:  labels <- repFlowMeans(data, lineage_channels)

  # Construct the small sample for determining the stability:
  data <- data[, lineage_channels]
  # data_1k <- expr[expr$population=="CD4pos", lineage_channels]
  sample_1k <- getSample(data, n = n_stable, seed = seed)
  sample_1k_ids <- getIDs(sample_1k)
  data <- data[-sample_1k_ids, ]
  if(n <= 0){
    n = length(data[[1]])
  }
  labels <- list()
  # seed <- 44
  for(run in 0:(reps-1)){
    print(paste("Run", (run+1), "Seed:", seed))

    # Construct the sample (of size n) to use for the clustering
    sample_9k <- getSample(data, n = n-n_stable, seed = seed)
    sample <- rbind(sample_1k, sample_9k)

    # Create FlowFrame from data
    #data_FlowMeans <- flowCore::flowFrame(as.matrix(sample))
    # res <- flowMeans(data_FlowMeans, varNames = marker_cols, NumC = nclust)

    # Run FlowMeans
    res <- flowMeans(sample, varNames = marker_cols, NumC = nclust)#, Standardize = FALSE, addNoise = FALSE)
    res <- data.frame(cluster = res@Label)$cluster

    labels <- append(labels, list(res[1:length(sample_1k[[1]])]))
    seed <- seed + 1
  }
  #print(paste('The Mean Adjusted Rand Index:', meanAdjustedRandIndex(labels)))
  labels
}


repFlowSOM2 <- function(data, marker_cols, nclust = 21, n = 10000, n_stable = 1000, reps = 10, seed = 42){
  # This function runs FlowSOM clustering a number of times, exports the results, and compute the mean adjusted rand index.
  # Input:  data - a data.frame of cytometry data
  #         marker_cols - the coloumns fra data to be used for the clustering (e.g. lineage_channels)
  #         nclust - number of clusters generated by FlowSOM (NA to generate automatically)
  #         n - sample size
  #         n_stable - sample size of the stability determining sample
  #         reps - number of times the clustering will be repeated
  #         seed - for reproducability
  # Output: labels - the clustering results
  #         The mean adjusted rand index will be printed
  # Dependencies: The functions "getSample", "getIDs", and "meanAdjustedRandIndex".
  # Usage:  labels <- repFlowSOM(data, lineage_channels)
  
  # Construct the small sample for determining the stability:
  data <- data[, lineage_channels]
  # data_1k <- expr[expr$population=="CD4pos", lineage_channels]

  sample_1k <- getSample(data, n = n_stable, seed = seed)
  sample_1k_ids <- getIDs(sample_1k)
  # Construct the sample (of size n) to use for the clustering
  if(n <= 0){
    n = length(data[[1]])
  }
  sample_9k <- getSample(data[-sample_1k_ids, ], n = n-n_stable, seed = seed)
  sample <- rbind(sample_1k, sample_9k)

  labels <- list()
  seed_flow <- seed
  for(run in 0:(reps-1)){
    print(paste("Run", (run+1), "Seed:", seed_flow))
    # Create FlowFrame from data
    data_FlowSOM <- flowCore::flowFrame(as.matrix(sample))
    
    # Set seed for reproducibility
    set.seed(seed_flow)
    
    # Run FlowSOM (initial steps prior to meta-clustering)
    fSOM <- FlowSOM::ReadInput(data_FlowSOM, transform = FALSE, scale = FALSE, silent = TRUE)
    fSOM <- FlowSOM::BuildSOM(fSOM, colsToUse = marker_cols, silent = TRUE)
    fSOM <- FlowSOM::BuildMST(fSOM, silent = TRUE)
    
    # Extract cluster labels (pre meta-clustering) from output object
    labels_pre <- fSOM$map$mapping[, 1]
    
    # Run FlowSOM meta-clustering
    fSOM_Cluster <- FlowSOM::metaClustering_consensus(fSOM$map$codes, k = nclust, seed = seed_flow)
    
    labels <- append(labels, list(fSOM_Cluster[labels_pre][1:length(sample_1k[[1]])]))
    seed_flow <- seed_flow + 1
  }
  #print(paste('The Mean Adjusted Rand Index:', mean(meanAdjustedRandIndex(labels))))
  labels
}


file2param <- function(filename){
  # Convert a filename to a set of parameters
  load('parameter_grid.RData')
  filename <- gsub('.RData', '', opt$filename)
  filename <- strsplit(filename, '_')[[1]]
  
  patient <- filename[2]
  size <- filename[4]
  seed <- filename[3]
  nclust <- filename[5]
  
  param_index <- which(parameter_grid$patient == patient & parameter_grid$size == size & parameter_grid$seed == seed & parameter_grid$nclust == nclust)
  param_index
}





make_umap <- function(sample, label, seed = 42){
  # Perform dimensionality reduction on a sample using UMAP
  set.seed(seed)
  data_umap <- as.matrix(sample)
  set.seed(seed)
  out_umap <- umap(data_umap, n_neighbors = 15, min_dist = 0.2, metric = 'euclidean', method = 'naive')
  data_plot <- as.data.frame(out_umap$layout[,1:2])
  colnames(data_plot) <- c("UMAP1", "UMAP2")
  data_plot
}
plot_umap <- function(data_plot, label){
  # Plot a UMAP result
  data_plot[, "cluster"] <- as.factor(label)
  ggplot(data_plot, aes(x = UMAP1, y = UMAP2, color = cluster)) +
    geom_point(size = 0.2) +
    coord_fixed(ratio = 1) +
    guides(colour = guide_legend(override.aes = list(size=2))) +
    scale_fill_discrete(name = "Dose", labels = c("A", "B", "C")) +
    ggtitle("UMAP projection with FlowSOM clustering") +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
    # panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    theme_bw()
}


#### Initiate loading results (04_resultAnalysis)
loadResult <- function(version){
  load(paste0('../results/03_flow', version, 'Result.RData'))
  results[results=='1e+05'] <- '100000'
  results[results=='-1'] <- 'All'
  # results$trueLabelARI <- as.numeric(results$trueLabelARI)
  # results$trueLabelAMI <- as.numeric(results$trueLabelAMI)
  results$ARI <- as.numeric(results$ARI)
  results$AMI <- as.numeric(results$AMI)
  results$nclust <- factor(results$nclust)
  results$sampleSize <- factor(results$sampleSize, c('10000', '20000', '50000', '100000', 'All'))
  results$patient <- factor(results$patient, c('001', '284d2', '84-0001-01', '885d1', '885d3', '885d4', '885d5', 'Pat03', 'Pat05', "all"))
  results
}




## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summariezed
##   groupvars: a vector containing names of columns that contain grouping variables
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
##   Origin: http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  library(plyr)
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  
  # This does the summary. For each group's data frame, return a vector with
  # N, mean, and sd
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2(xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm)
                   )
                 },
                 measurevar
  )
  
  # Rename the "mean" column    
  datac <- rename(datac, c("mean" = measurevar))
  
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}
